<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Depot Notes Picker — Per‑Section Staging</title>
  <style>
    :root {
      --bg: #0f172a;        /* slate-900 */
      --panel: #0b1220;     /* custom */
      --muted: #111827;     /* gray-900 */
      --fg: #e5e7eb;        /* gray-200 */
      --fg-dim: #9ca3af;    /* gray-400 */
      --accent: #22d3ee;    /* cyan-400 */
      --ok: #10b981;        /* emerald-500 */
      --warn: #f59e0b;      /* amber-500 */
      --danger: #ef4444;    /* red-500 */
      --radius: 14px;
    }
    html, body { height: 100%; }
    body { margin: 0; background: linear-gradient(180deg, #0b1022, #0a0d18 20%, #0f172a 80%); color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .wrap { max-width: 1200px; margin: 24px auto; padding: 0 16px 48px; }

    header { display: grid; gap: 10px; grid-template-columns: 1fr auto; align-items: end; margin-bottom: 16px; }
    h1 { font-weight: 700; margin: 0; font-size: 24px; letter-spacing: 0.2px; }
    .sub { color: var(--fg-dim); font-size: 13px; }

    .toolbar { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .chip { background: var(--muted); border: 1px solid #273244; padding: 8px 10px; border-radius: 999px; display: inline-flex; gap: 8px; align-items: center; }

    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 14px; }

    .section { grid-column: span 12; background: rgba(17,24,39,0.75); border: 1px solid #20314a; border-radius: var(--radius); overflow: hidden; }
    .sec-head { display:flex; align-items:center; justify-content:space-between; gap: 8px; padding: 14px 16px; background: linear-gradient(180deg, #0e1628, #0b1322); border-bottom: 1px solid #1e2a43; }
    .sec-title { font-weight: 700; letter-spacing: 0.3px; }
    .sec-actions { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }

    .btn { appearance: none; border: 1px solid #243044; background: #111827; color: var(--fg); font-weight: 600; letter-spacing: .2px; padding: 8px 10px; border-radius: 10px; cursor: pointer; transition: transform .04s ease, border-color .15s ease, box-shadow .15s ease, background .15s ease; }
    .btn:hover { border-color: #2f415e; box-shadow: 0 0 0 2px rgba(34,211,238,.12) inset; }
    .btn:active { transform: translateY(1px); }
    .btn.ok { border-color: #1e6b54; box-shadow: 0 0 0 2px rgba(16,185,129,.12) inset; }
    .btn.warn { border-color: #6b4e1e; box-shadow: 0 0 0 2px rgba(245,158,11,.12) inset; }

    .search { min-width: 220px; }
    .input { width: 100%; background: #0b1220; border: 1px solid #213049; color: var(--fg); padding: 9px 11px; border-radius: 10px; outline: none; transition: border-color .15s ease, box-shadow .15s ease; }
    .input::placeholder { color: #6b7280; }
    .input:focus { border-color: #33557a; box-shadow: 0 0 0 2px rgba(34,211,238,.1); }

    .cols { display: grid; grid-template-columns: 1fr; gap: 12px; padding: 12px 14px 16px; }
    @media (min-width: 900px) { .cols { grid-template-columns: 1.2fr 1fr; } }

    .panel { background: var(--panel); border: 1px solid #20314a; border-radius: var(--radius); padding: 12px; display: grid; gap: 10px; }
    .list { max-height: 280px; overflow: auto; display: grid; gap: 6px; }
    .row { display: flex; gap: 10px; align-items: center; background: #0a0f1d; border: 1px solid #1a2740; padding: 8px 10px; border-radius: 10px; }
    .code { font-family: ui-monospace, Menlo, Consolas, monospace; color: var(--accent); font-size: 12px; }
    .text { flex: 1; }
    .pill { padding: 3px 8px; border: 1px solid #2a3a56; border-radius: 999px; font-size: 12px; color: var(--fg-dim); }

    .copyta { width: 100%; min-height: 96px; background: #07101f; border: 1px solid #1d2b45; color: var(--fg); padding: 10px; border-radius: 10px; resize: vertical; }
    .muted { color: var(--fg-dim); font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Depot Notes Picker (Per‑Section Staging)</h1>
        <div class="sub">Tick lines in each section → <strong>Copy to Depot Section</strong> to stage → then <strong>Copy Depot Section</strong> into Depot.</div>
      </div>
      <div class="toolbar">
        <label class="chip"><input id="includeHeaders" type="checkbox" checked> <span>Include section headers</span></label>
        <label class="chip"><input id="semicolonLines" type="checkbox" checked> <span>Use “;” line breaks</span></label>
      </div>
    </header>

    <div id="grid" class="grid" aria-live="polite"></div>
  </div>

  <script>
  // ---- Optional API config (for GPT-style prose per section) --------------
  const CONFIG = {
    GPT_URL: '' // e.g. 'https://your-worker.example.com/section'
  };

  // ---- Load options --------------------------------------------------------
  async function loadOptions() {
    try {
      const res = await fetch('./options.json', { cache: 'no-store' });
      if (!res.ok) throw new Error('No options.json');
      const json = await res.json();
      return json.sections ? json.sections : json;
    } catch (e) {
      console.warn('Falling back to demo options:', e.message);
      return {
        'Needs': [
          { code:'NE01', text:'Better water pressure' },
          { code:'NE02', text:'Faster hot water delivery' },
          { code:'NE03', text:'More usable space' }
        ],
        'System Characteristics': [
          { code:'SC01', text:'System type – Regular' },
          { code:'SC03', text:'Pressurisation – Sealed' },
          { code:'SC05', text:'Primary circuit – Fully pumped' }
        ]
      };
    }
  }

  // ---- State --------------------------------------------------------------
  const state = {
    sections: {}, // name -> { items, selected:Set, filter:string, staged:string, notes:string, gpt:string }
    includeHeaders: true,
    semicolonLines: true,
  };

  // ---- Helpers ------------------------------------------------------------
  const el = (sel, root=document) => root.querySelector(sel);
  const els = (sel, root=document) => [...root.querySelectorAll(sel)];
  const escape = (s='') => String(s).replace(/[&<>\"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));

  function visibleItems(s){
    if(!s.filter) return s.items;
    const q = s.filter.toLowerCase();
    return s.items.filter(it => (it.text||'').toLowerCase().includes(q) || (it.code||'').toLowerCase().includes(q));
  }

  function linesForSection(name){
    const s = state.sections[name];
    const items = s.items.filter(it => s.selected.has(it.id));
    const out = [];
    if (state.includeHeaders && items.length) out.push(name + ':');
    for (const it of items) out.push(it.text);
    if ((s.notes||'').trim()) out.push('Notes: ' + s.notes.trim());
    return state.semicolonLines ? out.join('; ') : out.join('\n');
  }

  async function copy(text){ try{ await navigator.clipboard.writeText(text); }catch(e){ console.warn('Clipboard failed', e); } }

  // ---- Render -------------------------------------------------------------
  function renderSection(name){
    const s = state.sections[name];
    const grid = el('#grid');

    const sec = document.createElement('section');
    sec.className = 'section';

    // Header
    const head = document.createElement('div');
    head.className = 'sec-head';

    const title = document.createElement('div');
    title.className = 'sec-title';
    const count = document.createElement('span');
    count.className = 'pill';
    count.id = `count-${name}`;
    title.innerHTML = `${escape(name)} `;
    title.appendChild(count);

    const actions = document.createElement('div');
    actions.className = 'sec-actions';

    // Search
    const searchWrap = document.createElement('div');
    searchWrap.className = 'search';
    const search = document.createElement('input');
    search.className = 'input'; search.type='search'; search.placeholder='Filter this section…'; search.value=s.filter;
    search.addEventListener('input', ()=>{ s.filter = search.value; renderList(); });
    searchWrap.appendChild(search);

    // Buttons
    const btnSelectAll = document.createElement('button');
    btnSelectAll.className='btn'; btnSelectAll.textContent='Select All (visible)';
    btnSelectAll.addEventListener('click', ()=>{ visibleItems(s).forEach(it=>s.selected.add(it.id)); renderList(); });

    const btnClear = document.createElement('button');
    btnClear.className='btn warn'; btnClear.textContent='Clear Section';
    btnClear.addEventListener('click', ()=>{ s.selected.clear(); s.notes=''; s.staged=''; s.gpt=''; renderList(); });

    const btnStage = document.createElement('button');
    btnStage.className='btn ok'; btnStage.textContent='Copy to Depot Section';
    btnStage.title = 'Build from ticks + notes and stage below (also copied)';
    btnStage.addEventListener('click', async ()=>{
      s.staged = linesForSection(name);
      await copy(s.staged);
      renderStaging();
    });

    const btnGPT = document.createElement('button');
    btnGPT.className='btn'; btnGPT.textContent='Build via GPT';
    btnGPT.style.display = CONFIG.GPT_URL ? 'inline-block' : 'none';
    btnGPT.addEventListener('click', async ()=>{
      if(!CONFIG.GPT_URL) return;
      const payload = {
        section: name,
        selected: s.items.filter(it=>s.selected.has(it.id)).map(({code,text})=>({code,text})),
        notes: s.notes||''
      };
      try{
        const res = await fetch(CONFIG.GPT_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload)});
        const data = await res.json();
        s.gpt = (data && (data.text||data.output||data.result)) || '';
      }catch(e){ s.gpt = '⚠️ API error — check endpoint.'; }
      renderStaging();
    });

    actions.append(searchWrap, btnSelectAll, btnClear, btnStage, btnGPT);
    head.append(title, actions);

    // Columns: left = list, right = notes + staging
    const cols = document.createElement('div'); cols.className='cols';

    // LEFT: list
    const left = document.createElement('div'); left.className='panel';
    const list = document.createElement('div'); list.className='list';
    left.append(list);

    // RIGHT: notes + staged outputs
    const right = document.createElement('div'); right.className='panel';

    const notesLabel = document.createElement('div'); notesLabel.innerHTML = '<strong>Manual notes (included in Depot section & GPT):</strong>';
    const notes = document.createElement('textarea'); notes.className='copyta'; notes.placeholder='Add any free-typed notes for this section…'; notes.value=s.notes||'';
    notes.addEventListener('input', ()=>{ s.notes = notes.value; });

    const stagedLabel = document.createElement('div'); stagedLabel.innerHTML = '<strong>Depot Section Output</strong> <span class="muted">(copy into Depot)</span>';
    const staged = document.createElement('textarea'); staged.className='copyta'; staged.readOnly=true; staged.value=s.staged||'';

    const actions2 = document.createElement('div'); actions2.style.display='flex'; actions2.style.gap='8px'; actions2.style.flexWrap='wrap';
    const btnCopyStaged = document.createElement('button'); btnCopyStaged.className='btn ok'; btnCopyStaged.textContent='Copy Depot Section'; btnCopyStaged.addEventListener('click', async()=>{ await copy(staged.value); });
    const btnRebuild = document.createElement('button'); btnRebuild.className='btn'; btnRebuild.textContent='Rebuild from ticks + notes'; btnRebuild.addEventListener('click', ()=>{ s.staged = linesForSection(name); staged.value=s.staged; });

    const gptLabel = document.createElement('div'); gptLabel.innerHTML = '<strong>GPT Output</strong> <span class="muted">(from API; optional)</span>';
    const gptOut = document.createElement('textarea'); gptOut.className='copyta'; gptOut.readOnly=true; gptOut.value=s.gpt||'';
    const btnCopyGPT = document.createElement('button'); btnCopyGPT.className='btn'; btnCopyGPT.textContent='Copy GPT Output'; btnCopyGPT.addEventListener('click', async()=>{ await copy(gptOut.value); });

    right.append(notesLabel, notes, stagedLabel, staged, actions2, gptLabel, gptOut, btnCopyGPT);
    actions2.append(btnCopyStaged, btnRebuild);

    // Mount
    sec.append(head, (function(){ cols.append(left,right); return cols; })());
    grid.appendChild(sec);

    // Renderers
    function renderCounts(){ el(`#count-${CSS.escape(name)}`).textContent = `${s.selected.size} selected`; }

    function renderList(){
      renderCounts();
      list.innerHTML='';
      for (const it of visibleItems(s)){
        const row = document.createElement('label'); row.className='row';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.checked = s.selected.has(it.id);
        cb.addEventListener('change', ()=>{ cb.checked ? s.selected.add(it.id) : s.selected.delete(it.id); renderCounts(); });
        const code = document.createElement('span'); code.className='code'; code.textContent = it.code;
        const text = document.createElement('span'); text.className='text'; text.textContent = it.text;
        row.append(cb, code, text);
        list.appendChild(row);
      }
    }

    function renderStaging(){ staged.value = s.staged||''; gptOut.value = s.gpt||''; }

    // expose
    sec.__renderList = renderList;

    renderList();
    renderStaging();
  }

  // ---- Init ---------------------------------------------------------------
  (async function init(){
    const sections = await loadOptions();
    // normalize
    for (const [name, arr] of Object.entries(sections)){
      const items = (arr||[]).map((x,i)=>({ code: x.code ?? x.CODE ?? `X${i+1}`, text: x.text ?? x.Specific ?? x.specific ?? x.desc ?? x.description ?? String(x), id: `${name}::${x.code ?? x.CODE ?? i}` }));
      state.sections[name] = { items, selected:new Set(), filter:'', staged:'', notes:'', gpt:'' };
    }
    el('#includeHeaders').addEventListener('change', (e)=>{ state.includeHeaders = e.target.checked; });
    el('#semicolonLines').addEventListener('change', (e)=>{ state.semicolonLines = e.target.checked; });

    el('#grid').innerHTML='';
    for (const name of Object.keys(state.sections)) renderSection(name);
  })();
  </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Depot Notes Picker — Per‑Section Staging</title>
  <style>
    :root {
      --bg: #0f172a;        /* slate-900 */
      --panel: #0b1220;     /* custom */
      --muted: #111827;     /* gray-900 */
      --fg: #e5e7eb;        /* gray-200 */
      --fg-dim: #9ca3af;    /* gray-400 */
      --accent: #22d3ee;    /* cyan-400 */
      --ok: #10b981;        /* emerald-500 */
      --warn: #f59e0b;      /* amber-500 */
      --danger: #ef4444;    /* red-500 */
      --radius: 14px;
    }
    html, body { height: 100%; }
    body { margin: 0; background: linear-gradient(180deg, #0b1022, #0a0d18 20%, #0f172a 80%); color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .wrap { max-width: 1200px; margin: 24px auto; padding: 0 16px 48px; }

    header { display: grid; gap: 10px; grid-template-columns: 1fr auto; align-items: end; margin-bottom: 16px; }
    h1 { font-weight: 700; margin: 0; font-size: 24px; letter-spacing: 0.2px; }
    .sub { color: var(--fg-dim); font-size: 13px; }

    .toolbar { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .chip { background: var(--muted); border: 1px solid #273244; padding: 8px 10px; border-radius: 999px; display: inline-flex; gap: 8px; align-items: center; }

    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 14px; }

    .section { grid-column: span 12; background: rgba(17,24,39,0.75); border: 1px solid #20314a; border-radius: var(--radius); overflow: hidden; }
    .sec-head { display:flex; align-items:center; justify-content:space-between; gap: 8px; padding: 14px 16px; background: linear-gradient(180deg, #0e1628, #0b1322); border-bottom: 1px solid #1e2a43; }
    .sec-title { font-weight: 700; letter-spacing: 0.3px; }
    .sec-actions { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }

    .btn { appearance: none; border: 1px solid #243044; background: #111827; color: var(--fg); font-weight: 600; letter-spacing: .2px; padding: 8px 10px; border-radius: 10px; cursor: pointer; transition: transform .04s ease, border-color .15s ease, box-shadow .15s ease, background .15s ease; }
    .btn:hover { border-color: #2f415e; box-shadow: 0 0 0 2px rgba(34,211,238,.12) inset; }
    .btn:active { transform: translateY(1px); }
    .btn.ok { border-color: #1e6b54; box-shadow: 0 0 0 2px rgba(16,185,129,.12) inset; }
    .btn.warn { border-color: #6b4e1e; box-shadow: 0 0 0 2px rgba(245,158,11,.12) inset; }

    .search { min-width: 220px; }
    .input { width: 100%; background: #0b1220; border: 1px solid #213049; color: var(--fg); padding: 9px 11px; border-radius: 10px; outline: none; transition: border-color .15s ease, box-shadow .15s ease; }
    .input::placeholder { color: #6b7280; }
    .input:focus { border-color: #33557a; box-shadow: 0 0 0 2px rgba(34,211,238,.1); }

    .cols { display: grid; grid-template-columns: 1fr; gap: 12px; padding: 12px 14px 16px; }
    @media (min-width: 900px) { .cols { grid-template-columns: 1.2fr 1fr; } }

    .panel { background: var(--panel); border: 1px solid #20314a; border-radius: var(--radius); padding: 12px; display: grid; gap: 10px; }
    .list { max-height: 280px; overflow: auto; display: grid; gap: 6px; }
    .row { display: flex; gap: 10px; align-items: center; background: #0a0f1d; border: 1px solid #1a2740; padding: 8px 10px; border-radius: 10px; }
    .code { font-family: ui-monospace, Menlo, Consolas, monospace; color: var(--accent); font-size: 12px; }
    .text { flex: 1; }
    .pill { padding: 3px 8px; border: 1px solid #2a3a56; border-radius: 999px; font-size: 12px; color: var(--fg-dim); }

    .copyta { width: 100%; min-height: 96px; background: #07101f; border: 1px solid #1d2b45; color: var(--fg); padding: 10px; border-radius: 10px; resize: vertical; }
    .muted { color: var(--fg-dim); font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Depot Notes Picker (Per‑Section Staging)</h1>
        <div class="sub">Tick lines in each section → <strong>Copy to Depot Section</strong> to stage → then <strong>Copy Depot Section</strong> into Depot.</div>
      </div>
      <div class="toolbar">
        <label class="chip"><input id="includeHeaders" type="checkbox" checked> <span>Include section headers</span></label>
        <label class="chip"><input id="semicolonLines" type="checkbox" checked> <span>Use “;” line breaks</span></label>
      </div>
    </header>

    <div id="grid" class="grid" aria-live="polite"></div>
  </div>

  <script>
  // ---- Optional API config (for GPT-style prose per section) --------------
  const CONFIG = {
    GPT_URL: '' // e.g. 'https://your-worker.example.com/section'
  };

  // ---- Load options --------------------------------------------------------
  async function loadOptions() {
    try {
      const res = await fetch('./options.json', { cache: 'no-store' });
      if (!res.ok) throw new Error('No options.json');
      const json = await res.json();
      return json.sections ? json.sections : json;
    } catch (e) {
      console.warn('Falling back to demo options:', e.message);
      return {
        'Needs': [
          { code:'NE01', text:'Better water pressure' },
          { code:'NE02', text:'Faster hot water delivery' },
          { code:'NE03', text:'More usable space' }
        ],
        'System Characteristics': [
          { code:'SC01', text:'System type – Regular' },
          { code:'SC03', text:'Pressurisation – Sealed' },
          { code:'SC05', text:'Primary circuit – Fully pumped' }
        ]
      };
    }
  }

  // ---- State --------------------------------------------------------------
  const state = {
    sections: {}, // name -> { items, selected:Set, filter:string, staged:string, notes:string, gpt:string }
    includeHeaders: true,
    semicolonLines: true,
  };

  // ---- Helpers ------------------------------------------------------------
  const el = (sel, root=document) => root.querySelector(sel);
  const els = (sel, root=document) => [...root.querySelectorAll(sel)];
  const escape = (s='') => String(s).replace(/[&<>\"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));

  function visibleItems(s){
    if(!s.filter) return s.items;
    const q = s.filter.toLowerCase();
    return s.items.filter(it => (it.text||'').toLowerCase().includes(q) || (it.code||'').toLowerCase().includes(q));
  }

  function linesForSection(name){
    const s = state.sections[name];
    const items = s.items.filter(it => s.selected.has(it.id));
    const out = [];
    if (state.includeHeaders && items.length) out.push(name + ':');
    for (const it of items) out.push(it.text);
    if ((s.notes||'').trim()) out.push('Notes: ' + s.notes.trim());
    return state.semicolonLines ? out.join('; ') : out.join('\n');
  }

  async function copy(text){ try{ await navigator.clipboard.writeText(text); }catch(e){ console.warn('Clipboard failed', e); } }

  // ---- Render -------------------------------------------------------------
  function renderSection(name){
    const s = state.sections[name];
    const grid = el('#grid');

    const sec = document.createElement('section');
    sec.className = 'section';

    // Header
    const head = document.createElement('div');
    head.className = 'sec-head';

    const title = document.createElement('div');
    title.className = 'sec-title';
    const count = document.createElement('span');
    count.className = 'pill';
    count.id = `count-${name}`;
    title.innerHTML = `${escape(name)} `;
    title.appendChild(count);

    const actions = document.createElement('div');
    actions.className = 'sec-actions';

    // Search
    const searchWrap = document.createElement('div');
    searchWrap.className = 'search';
    const search = document.createElement('input');
    search.className = 'input'; search.type='search'; search.placeholder='Filter this section…'; search.value=s.filter;
    search.addEventListener('input', ()=>{ s.filter = search.value; renderList(); });
    searchWrap.appendChild(search);

    // Buttons
    const btnSelectAll = document.createElement('button');
    btnSelectAll.className='btn'; btnSelectAll.textContent='Select All (visible)';
    btnSelectAll.addEventListener('click', ()=>{ visibleItems(s).forEach(it=>s.selected.add(it.id)); renderList(); });

    const btnClear = document.createElement('button');
    btnClear.className='btn warn'; btnClear.textContent='Clear Section';
    btnClear.addEventListener('click', ()=>{ s.selected.clear(); s.notes=''; s.staged=''; s.gpt=''; renderList(); });

    const btnStage = document.createElement('button');
    btnStage.className='btn ok'; btnStage.textContent='Copy to Depot Section';
    btnStage.title = 'Build from ticks + notes and stage below (also copied)';
    btnStage.addEventListener('click', async ()=>{
      s.staged = linesForSection(name);
      await copy(s.staged);
      renderStaging();
    });

    const btnGPT = document.createElement('button');
    btnGPT.className='btn'; btnGPT.textContent='Build via GPT';
    btnGPT.style.display = CONFIG.GPT_URL ? 'inline-block' : 'none';
    btnGPT.addEventListener('click', async ()=>{
      if(!CONFIG.GPT_URL) return;
      const payload = {
        section: name,
        selected: s.items.filter(it=>s.selected.has(it.id)).map(({code,text})=>({code,text})),
        notes: s.notes||''
      };
      try{
        const res = await fetch(CONFIG.GPT_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload)});
        const data = await res.json();
        s.gpt = (data && (data.text||data.output||data.result)) || '';
      }catch(e){ s.gpt = '⚠️ API error — check endpoint.'; }
      renderStaging();
    });

    actions.append(searchWrap, btnSelectAll, btnClear, btnStage, btnGPT);
    head.append(title, actions);

    // Columns: left = list, right = notes + staging
    const cols = document.createElement('div'); cols.className='cols';

    // LEFT: list
    const left = document.createElement('div'); left.className='panel';
    const list = document.createElement('div'); list.className='list';
    left.append(list);

    // RIGHT: notes + staged outputs
    const right = document.createElement('div'); right.className='panel';

    const notesLabel = document.createElement('div'); notesLabel.innerHTML = '<strong>Manual notes (included in Depot section & GPT):</strong>';
    const notes = document.createElement('textarea'); notes.className='copyta'; notes.placeholder='Add any free-typed notes for this section…'; notes.value=s.notes||'';
    notes.addEventListener('input', ()=>{ s.notes = notes.value; });

    const stagedLabel = document.createElement('div'); stagedLabel.innerHTML = '<strong>Depot Section Output</strong> <span class="muted">(copy into Depot)</span>';
    const staged = document.createElement('textarea'); staged.className='copyta'; staged.readOnly=true; staged.value=s.staged||'';

    const actions2 = document.createElement('div'); actions2.style.display='flex'; actions2.style.gap='8px'; actions2.style.flexWrap='wrap';
    const btnCopyStaged = document.createElement('button'); btnCopyStaged.className='btn ok'; btnCopyStaged.textContent='Copy Depot Section'; btnCopyStaged.addEventListener('click', async()=>{ await copy(staged.value); });
    const btnRebuild = document.createElement('button'); btnRebuild.className='btn'; btnRebuild.textContent='Rebuild from ticks + notes'; btnRebuild.addEventListener('click', ()=>{ s.staged = linesForSection(name); staged.value=s.staged; });

    const gptLabel = document.createElement('div'); gptLabel.innerHTML = '<strong>GPT Output</strong> <span class="muted">(from API; optional)</span>';
    const gptOut = document.createElement('textarea'); gptOut.className='copyta'; gptOut.readOnly=true; gptOut.value=s.gpt||'';
    const btnCopyGPT = document.createElement('button'); btnCopyGPT.className='btn'; btnCopyGPT.textContent='Copy GPT Output'; btnCopyGPT.addEventListener('click', async()=>{ await copy(gptOut.value); });

    right.append(notesLabel, notes, stagedLabel, staged, actions2, gptLabel, gptOut, btnCopyGPT);
    actions2.append(btnCopyStaged, btnRebuild);

    // Mount
    sec.append(head, (function(){ cols.append(left,right); return cols; })());
    grid.appendChild(sec);

    // Renderers
    function renderCounts(){ el(`#count-${CSS.escape(name)}`).textContent = `${s.selected.size} selected`; }

    function renderList(){
      renderCounts();
      list.innerHTML='';
      for (const it of visibleItems(s)){
        const row = document.createElement('label'); row.className='row';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.checked = s.selected.has(it.id);
        cb.addEventListener('change', ()=>{ cb.checked ? s.selected.add(it.id) : s.selected.delete(it.id); renderCounts(); });
        const code = document.createElement('span'); code.className='code'; code.textContent = it.code;
        const text = document.createElement('span'); text.className='text'; text.textContent = it.text;
        row.append(cb, code, text);
        list.appendChild(row);
      }
    }

    function renderStaging(){ staged.value = s.staged||''; gptOut.value = s.gpt||''; }

    // expose
    sec.__renderList = renderList;

    renderList();
    renderStaging();
  }

  // ---- Init ---------------------------------------------------------------
  (async function init(){
    const sections = await loadOptions();
    // normalize
    for (const [name, arr] of Object.entries(sections)){
      const items = (arr||[]).map((x,i)=>({ code: x.code ?? x.CODE ?? `X${i+1}`, text: x.text ?? x.Specific ?? x.specific ?? x.desc ?? x.description ?? String(x), id: `${name}::${x.code ?? x.CODE ?? i}` }));
      state.sections[name] = { items, selected:new Set(), filter:'', staged:'', notes:'', gpt:'' };
    }
    el('#includeHeaders').addEventListener('change', (e)=>{ state.includeHeaders = e.target.checked; });
    el('#semicolonLines').addEventListener('change', (e)=>{ state.semicolonLines = e.target.checked; });

    el('#grid').innerHTML='';
    for (const name of Object.keys(state.sections)) renderSection(name);
  })();
  </script>
</body>
</html>