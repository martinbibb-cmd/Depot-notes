<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Depot Notes Picker — Targets + Clean Copy</title>
  <style>
    :root{--bg:#0f172a;--panel:#0b1220;--muted:#111827;--fg:#e5e7eb;--fg-dim:#9ca3af;--accent:#22d3ee;--ok:#10b981;--warn:#f59e0b;--danger:#ef4444;--radius:14px}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b1022,#0a0d18 20%,#0f172a 80%);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial,Apple Color Emoji,Segoe UI Emoji}
    .wrap{max-width:1240px;margin:24px auto;padding:0 16px 48px}
    header{display:grid;gap:10px;grid-template-columns:1fr auto;align-items:end;margin-bottom:16px}
    h1{font-weight:700;margin:0;font-size:24px;letter-spacing:.2px}
    .sub{color:var(--fg-dim);font-size:13px}
    .toolbar{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .chip{background:var(--muted);border:1px solid #273244;padding:8px 10px;border-radius:999px;display:inline-flex;gap:8px;align-items:center}
    .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:14px}
    .section{grid-column:span 12;background:rgba(17,24,39,.75);border:1px solid #20314a;border-radius:var(--radius);overflow:hidden}
    .sec-head{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:14px 16px;background:linear-gradient(180deg,#0e1628,#0b1322);border-bottom:1px solid #1e2a43}
    .sec-title{font-weight:700;letter-spacing:.3px}
    .sec-actions{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .btn{appearance:none;border:1px solid #243044;background:#111827;color:var(--fg);font-weight:600;letter-spacing:.2px;padding:8px 10px;border-radius:10px;cursor:pointer;transition:transform .04s ease,border-color .15s ease,box-shadow .15s ease,background .15s ease}
    .btn:hover{border-color:#2f415e;box-shadow:0 0 0 2px rgba(34,211,238,.12) inset}
    .btn:active{transform:translateY(1px)}
    .btn.ok{border-color:#1e6b54;box-shadow:0 0 0 2px rgba(16,185,129,.12) inset}
    .btn.warn{border-color:#6b4e1e;box-shadow:0 0 0 2px rgba(245,158,11,.12) inset}
    .search{min-width:220px}
    .input{width:100%;background:#0b1220;border:1px solid #213049;color:var(--fg);padding:9px 11px;border-radius:10px;outline:none;transition:border-color .15s ease,box-shadow .15s ease}
    .input::placeholder{color:#6b7280}
    .input:focus{border-color:#33557a;box-shadow:0 0 0 2px rgba(34,211,238,.1)}
    .cols{display:grid;grid-template-columns:1fr;gap:12px;padding:12px 14px 16px}
    @media(min-width:1000px){.cols{grid-template-columns:1.2fr 1fr}}
    .panel{background:var(--panel);border:1px solid #20314a;border-radius:var(--radius);padding:12px;display:grid;gap:10px}
    .list{max-height:280px;overflow:auto;display:grid;gap:6px}
    .row{display:flex;gap:10px;align-items:center;background:#0a0f1d;border:1px solid #1a2740;padding:8px 10px;border-radius:10px}
    .code{font-family:ui-monospace,Menlo,Consolas,monospace;color:var(--accent);font-size:12px}
    .text{flex:1}
    .pill{padding:3px 8px;border:1px solid #2a3a56;border-radius:999px;font-size:12px;color:var(--fg-dim)}
    .copyta{width:100%;min-height:96px;background:#07101f;border:1px solid #1d2b45;color:var(--fg);padding:10px;border-radius:10px;resize:vertical}
    .muted{color:var(--fg-dim);font-size:12px}
    .fields{display:grid;gap:8px}
    .field{display:grid;gap:6px}
    .label{font-size:13px;color:var(--fg);opacity:.9}
    .targets{margin-top:22px}
    .target{background:rgba(17,24,39,.75);border:1px solid #20314a;border-radius:var(--radius);padding:12px;display:grid;gap:8px}
    .target h3{margin:0 0 6px 0;font-size:15px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Depot Notes Picker (Targets + Clean Copy)</h1>
        <div class="sub">Tick lines → build per‑section output → send to any Depot target → copy clean text (no URL encoding). Options load from Options.txt or options.json.</div>
      </div>
      <div class="toolbar">
        <label class="chip"><input id="includeHeaders" type="checkbox" checked> <span>Include section headers</span></label>
        <label class="chip"><input id="semicolonLines" type="checkbox" checked> <span>Use “;” line breaks</span></label>
        <div class="chip">Send to target:
          <select id="globalTarget" class="input" style="min-width:200px"></select>
        </div>
      </div>
    </header>

    <div id="grid" class="grid" aria-live="polite"></div>

    <div class="targets" id="targets"></div>
  </div>

  <script>
  const CONFIG = { GPT_URL: '' };

  // ---------- Loading ----------
  async function loadOptions(){
    try{ const r=await fetch('./options.json',{cache:'no-store'}); if(r.ok){const j=await r.json(); return j.sections??j;} }catch(e){}
    try{ const r=await fetch('./Options.txt',{cache:'no-store'}); if(r.ok){ const t=await r.text(); const p=parseOptionsTxt(t); if(Object.keys(p).length) return p; } }catch(e){}
    return { 'Needs': { items:[{code:'NE01',text:'Better water pressure'}] } };
  }

  // ---------- State ----------
  const state={ sections:{}, targets:{}, includeHeaders:true, semicolonLines:true };

  // ---------- Helpers ----------
  const el=(s,r=document)=>r.querySelector(s);
  const escapeHtml=s=>String(s).replace(/[&<>\"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));

  // robust plain-text copy (iOS-safe, avoids URL encoding)
  async function copyPlain(text){
    try{
      if(navigator.clipboard && window.ClipboardItem){
        const item=new ClipboardItem({ 'text/plain': new Blob([text],{type:'text/plain'}) });
        await navigator.clipboard.write([item]);
        return;
      }
    }catch(e){}
    // fallback: hidden textarea + execCommand
    const ta=document.createElement('textarea');
    ta.style.position='fixed'; ta.style.opacity='0'; ta.value=text.replace(/\u2013|\u2014/g,'-').replace(/[\u2018\u2019]/g,"'").replace(/[\u201c\u201d]/g,'"');
    document.body.appendChild(ta); ta.focus(); ta.select();
    try{ document.execCommand('copy'); }catch(e){}
    ta.remove();
  }

  // Build output for a section
  function linesForSection(name){
    const s=state.sections[name]; const items=s.items.filter(it=>s.selected.has(it.id)); const out=[];
    if(state.includeHeaders && (items.length || hasAnyFieldValue(s) || (s.notes||'').trim())) out.push(name+':');
    for(const it of items) out.push(it.text);
    if(s.fields && s.fields.length){ for(const f of s.fields){ const v=(s.fieldValues[f.key]??'').toString().trim(); if(v) out.push(`${f.label||f.key}: ${v}`); } }
    if((s.notes||'').trim()) out.push('Notes: '+s.notes.trim());
    return state.semicolonLines? out.join('; ') : out.join('\n');
  }

  function hasAnyFieldValue(s){ return (s.fields||[]).some(f=> (s.fieldValues[f.key]??'').toString().trim()); }
  function visibleItems(s){ if(!s.filter) return s.items; const q=s.filter.toLowerCase(); return s.items.filter(it=>(it.text||'').toLowerCase().includes(q) || (it.code||'').toLowerCase().includes(q)); }

  // Parse Options.txt (enhanced):
  // [section_key]
  // CODE | Category | Specific  (or) CODE | Text  (or) Text only
  // FIELD | key | label | type | optionsCSV | placeholder
  // TARGET | key | label
  // MAP | target_key | section_key  (attach a section to a Depot target)
  function parseOptionsTxt(src){
    const lines=src.split(/\r?\n/g); const sections={}; const targets={}; const maps=[];
    let current=null; const toTitle=s=>s.replace(/[_-]+/g,' ').replace(/\b\w/g,m=>m.toUpperCase());
    for(const raw of lines){
      const line=raw.trim(); if(!line || line.startsWith('#') || line.startsWith('//')) continue;
      const mh=line.match(/^\[(.+?)\]$/); if(mh){ current=toTitle(mh[1].trim()); sections[current] ||= {items:[], fields:[]}; continue; }
      const parts=line.split('|').map(s=>s.trim());
      if((parts[0]||'').toUpperCase()==='FIELD'){ const [_,key,label,type='text',optCsv='',placeholder='']=parts; const options=optCsv?optCsv.split(',').map(s=>s.trim()).filter(Boolean):undefined; sections[current].fields.push({key,label:label||key,type:type.toLowerCase(),...(options?{options}:{}),...(placeholder?{placeholder}:{}),}); continue; }
      if((parts[0]||'').toUpperCase()==='TARGET'){ const [_,key,label]=parts; targets[key]={ key, label:label||toTitle(key), value:'' }; continue; }
      if((parts[0]||'').toUpperCase()==='MAP'){ const [_,tKey,sKey]=parts; maps.push({tKey,sKey}); continue; }
      // item line
      if(parts.length>=3){ sections[current].items.push({code:parts[0], text:parts[2]}); }
      else if(parts.length===2){ sections[current].items.push({code:parts[0], text:parts[1]}); }
      else { const text=parts[0]; const code='X'+(sections[current].items.length+1).toString().padStart(3,'0'); sections[current].items.push({code,text}); }
    }
    // store targets and maps on a hidden pseudo-section for return
    sections.__TARGETS__={items:[],fields:[],__targets:targets,__maps:maps};
    return sections;
  }

  // ---------- Render Section cards ----------
  function renderSection(name){ if(name==='__TARGETS__') return; const s=state.sections[name]; const grid=el('#grid');
    const sec=document.createElement('section'); sec.className='section';
    const head=document.createElement('div'); head.className='sec-head';
    const title=document.createElement('div'); title.className='sec-title'; const count=document.createElement('span'); count.className='pill'; count.id=`count-${name}`; title.innerHTML=`${escapeHtml(name)} `; title.appendChild(count);
    const actions=document.createElement('div'); actions.className='sec-actions';
    const searchWrap=document.createElement('div'); searchWrap.className='search'; const search=document.createElement('input'); search.className='input'; search.type='search'; search.placeholder='Filter…'; search.value=s.filter||''; search.addEventListener('input',()=>{ s.filter=search.value; renderList(); }); searchWrap.appendChild(search);
    const btnAll=document.createElement('button'); btnAll.className='btn'; btnAll.textContent='Select All (visible)'; btnAll.addEventListener('click',()=>{ visibleItems(s).forEach(it=>s.selected.add(it.id)); renderList(); });
    const btnClear=document.createElement('button'); btnClear.className='btn warn'; btnClear.textContent='Clear'; btnClear.addEventListener('click',()=>{ s.selected.clear(); s.notes=''; s.staged=''; renderList(); renderRight(); });
    const tgtSel=document.createElement('select'); tgtSel.className='input'; tgtSel.style.minWidth='180px';
    function syncTgtSel(){ tgtSel.innerHTML=''; for(const k of Object.keys(state.targets)){ const o=document.createElement('option'); o.value=k; o.textContent=state.targets[k].label; tgtSel.appendChild(o);} tgtSel.value=el('#globalTarget').value; }
    syncTgtSel();
    const btnStage=document.createElement('button'); btnStage.className='btn ok'; btnStage.textContent='Send to Target'; btnStage.title='Stage this section and append into chosen Depot target';
    btnStage.addEventListener('click',async()=>{ s.staged=linesForSection(name); await copyPlain(s.staged); // copy clean
      const key=tgtSel.value; state.targets[key].value = [state.targets[key].value, s.staged].filter(Boolean).join(state.semicolonLines?'; ':"\n\n"); renderTargets(); });
    if(CONFIG.GPT_URL){ const btnGPT=document.createElement('button'); btnGPT.className='btn'; btnGPT.textContent='Build via GPT'; btnGPT.addEventListener('click',()=>buildViaGPT(name)); actions.append(btnGPT); }
    actions.append(searchWrap, btnAll, btnClear, tgtSel, btnStage);
    head.append(title, actions);

    const cols=document.createElement('div'); cols.className='cols';
    const left=document.createElement('div'); left.className='panel'; const list=document.createElement('div'); list.className='list'; left.append(list);
    const right=document.createElement('div'); right.className='panel';
    const notesLabel=document.createElement('div'); notesLabel.innerHTML='<strong>Manual notes</strong> <span class="muted">(included)</span>';
    const notes=document.createElement('textarea'); notes.className='copyta'; notes.placeholder='Free-typed notes…'; notes.value=s.notes||''; notes.addEventListener('input',()=>{ s.notes=notes.value; });
    const stagedLabel=document.createElement('div'); stagedLabel.innerHTML='<strong>Section Output</strong> <span class="muted">(clean copy)</span>';
    const staged=document.createElement('textarea'); staged.className='copyta'; staged.readOnly=true; staged.value=s.staged||'';
    const act2=document.createElement('div'); act2.style.display='flex'; act2.style.gap='8px';
    const bCopy=document.createElement('button'); bCopy.className='btn ok'; bCopy.textContent='Copy Section'; bCopy.addEventListener('click',()=>copyPlain(staged.value));
    const bRebuild=document.createElement('button'); bRebuild.className='btn'; bRebuild.textContent='Rebuild'; bRebuild.addEventListener('click',()=>{ s.staged=linesForSection(name); staged.value=s.staged; });
    right.append(notesLabel,notes,stagedLabel,staged,act2); act2.append(bCopy,bRebuild);

    sec.append(head,(function(){ cols.append(left,right); return cols; })()); grid.appendChild(sec);

    function renderCounts(){ el(`#count-${CSS.escape(name)}`).textContent=`${s.selected.size} selected`; }
    function renderList(){ renderCounts(); list.innerHTML=''; for(const it of visibleItems(s)){ const row=document.createElement('label'); row.className='row'; const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=s.selected.has(it.id); cb.addEventListener('change',()=>{ cb.checked?s.selected.add(it.id):s.selected.delete(it.id); renderCounts(); }); const code=document.createElement('span'); code.className='code'; code.textContent=it.code; const text=document.createElement('span'); text.className='text'; text.textContent=it.text; row.append(cb,code,text); list.appendChild(row);} }
    function renderRight(){ staged.value=s.staged||''; }
    renderList(); renderRight();
  }

  async function buildViaGPT(name){ const s=state.sections[name]; const payload={ section:name, selected:s.items.filter(it=>s.selected.has(it.id)).map(({code,text})=>({code,text})), fields:s.fieldValues||{}, notes:s.notes||'' }; try{ const r=await fetch(CONFIG.GPT_URL,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)}); const j=await r.json(); const txt=(j.text||j.output||j.result||'').trim(); s.staged = [linesForSection(name), txt].filter(Boolean).join(state.semicolonLines?'; ':"\n\n"); renderTargets(); }catch(e){ alert('GPT endpoint error'); } }

  // ---------- Targets panel ----------
  function renderTargets(){ const wrap=el('#targets'); wrap.innerHTML='';
    const h=document.createElement('h2'); h.textContent='Depot Targets'; wrap.appendChild(h);
    for(const [key,t] of Object.entries(state.targets)){
      const card=document.createElement('div'); card.className='target';
      const title=document.createElement('h3'); title.textContent=t.label; card.appendChild(title);
      const ta=document.createElement('textarea'); ta.className='copyta'; ta.value=t.value||''; ta.addEventListener('input',()=>{ t.value=ta.value; }); card.appendChild(ta);
      const row=document.createElement('div'); row.style.display='flex'; row.style.gap='8px';
      const bCopy=document.createElement('button'); bCopy.className='btn ok'; bCopy.textContent='Copy Target'; bCopy.addEventListener('click',()=>copyPlain(ta.value));
      const bClear=document.createElement('button'); bClear.className='btn warn'; bClear.textContent='Clear'; bClear.addEventListener('click',()=>{ t.value=''; ta.value=''; });
      row.append(bCopy,bClear); card.appendChild(row);
      wrap.appendChild(card);
    }
  }

  // ---------- Init ----------
  (async function init(){
    const sections=await loadOptions();
    // pull out TARGETS/MAP if present
    const tgtSec=sections.__TARGETS__ || { __targets:{}, __maps:[] };
    const targets = tgtSec.__targets || {};
    const maps = tgtSec.__maps || [];
    delete sections.__TARGETS__;

    // normalize sections
    for(const [name, raw] of Object.entries(sections)){
      const arr = Array.isArray(raw) ? raw : (raw.items||[]);
      const fields = Array.isArray(raw) ? [] : (raw.fields||[]);
      const items = (arr||[]).map((x,i)=>({ code:x.code??x.CODE??`X${i+1}`, text:x.text??x.Specific??x.specific??x.desc??x.description??String(x), id:`${name}::${x.code??x.CODE??i}`}));
      const fieldValues = Object.fromEntries((fields||[]).map(f=>[f.key,'']));
      state.sections[name] = { items, fields, fieldValues, selected:new Set(), filter:'', notes:'', staged:'' };
    }

    // build targets
    if(Object.keys(targets).length===0){ // sensible defaults
      ['Installer Notes – Flue','Installer Notes – Boiler','Installer Notes – Gas','Customer Summary'].forEach((lbl,i)=>{ const key='t'+i; state.targets[key]={key,label:lbl,value:''}; });
    }else{ state.targets = targets; }

    // render global target selector
    const sel=el('#globalTarget'); sel.innerHTML=''; for(const k of Object.keys(state.targets)){ const o=document.createElement('option'); o.value=k; o.textContent=state.targets[k].label; sel.appendChild(o); }

    // apply MAP lines (optional defaults): join mapped sections into given targets initially
    for(const m of maps){ const t=state.targets[m.tKey]; if(!t) continue; const sectionKey=(m.sKey||'').replace(/[_-]+/g,' ').replace(/\b\w/g,x=>x.toUpperCase()); const s=state.sections[sectionKey]; if(!s) continue; const built=linesForSection(sectionKey); t.value=[t.value,built].filter(Boolean).join(state.semicolonLines?'; ':"\n\n"); }

    el('#includeHeaders').addEventListener('change',e=>{ state.includeHeaders=e.target.checked; });
    el('#semicolonLines').addEventListener('change',e=>{ state.semicolonLines=e.target.checked; });

    // render sections + targets
    el('#grid').innerHTML=''; for(const name of Object.keys(state.sections)) renderSection(name);
    renderTargets();
  })();
  </script>
</body>
</html>
